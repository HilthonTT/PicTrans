@page "/"
@inject ISecureStorage secureStorage
@inject IImageService imageService
@inject IDialogService dialogService

<MudContainer>
    <h1 class="text-uppercase text-center">Convert Images</h1>
    @if (string.IsNullOrWhiteSpace(errorMessage) is false)
    {
        <MudAlert Severity="@((Severity)Enum.Parse(typeof(Severity), alertClass))">
            @errorMessage
        </MudAlert>
    }
    <MudGrid>
        <MudItem xs="12" Class="text-center">
            <MudFileUpload T="IReadOnlyList<IBrowserFile>" FilesChanged="UploadFiles" 
                Accept=".png;.jpeg.;.jpg;.gif;.bmp;.tiff;.webp;">
                <ButtonTemplate>
                    <MudButton HtmlTag="label"
                               Variant="Variant.Filled"
                               Color="MudBlazor.Color.Primary"
                               StartIcon="@Icons.Material.Filled.CloudUpload"
                               Class="w-100"
                               for="@context">
                        Multiple Files
                    </MudButton>
                </ButtonTemplate>
            </MudFileUpload>
            <MudButtonGroup Class="mt-2">
                <MudButton Class="@GetButtonClass(true)" OnClick="@(() => isDownloadFolder = true)">Download Folder</MudButton>
                <MudButton Class="@GetButtonClass(false)" OnClick="@(() => isDownloadFolder = false)">Picture Folder</MudButton>
            </MudButtonGroup>
            <MudSelect Label="Convert to:" @bind-Value="selectedExtension" Class="mud-input-root text-start">
                @foreach (var e in pictureExtensions)
                {
                    <MudSelectItem Value="@e">@e</MudSelectItem>
                }
            </MudSelect>
            <MudText Align="Align.Center" Class="mt-2">@progress.ToString("0")%</MudText>
            <MudProgressLinear Color="MudBlazor.Color.Primary" Buffer="true" Value="progress" BufferValue="bufferValue" Class="my-7" />
            <MudTextField @bind-Value="searchText" Label="Search" Variant="Variant.Outlined" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="MudBlazor.Color.Secondary" OnAdornmentClick="FilterImages"/>
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <MudText Align="Align.Start" Class="mt-2">@GetFilesCount()</MudText>
                </div>
                <div class="center-children">
                    <MudButtonGroup Variant="Variant.Outlined" Color="MudBlazor.Color.Primary" OverrideStyles="false" Class="mt-2">
                        @if (isConverted is false)
                        {
                            <MudButton Variant="Variant.Outlined" Color="MudBlazor.Color.Primary" OnClick="ConvertImages">
                                Convert
                            </MudButton>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Outlined" OnClick="DownloadImages">
                                Download
                            </MudButton>
                        }
                        @if (files.Count > 0)
                        {
                            <MudButton Variant="Variant.Outlined" Color="MudBlazor.Color.Error" OnClick="ClearImages">Clear</MudButton>
                        }
                    </MudButtonGroup>
                </div>
                <div></div> <!-- Add an empty div to create space at the end -->
            </div>
        </MudItem>
        <MudItem xs="12">
            <MudVirtualize Items="files" Context="f" OverscanCount="10">
                <File BrowserFile="f" IsDownloadFolder="isDownloadFolder"/>
            </MudVirtualize>
        </MudItem>
    </MudGrid>
</MudContainer>


@code {
    private const long maxFileSize = 1024 * 1024 * 500; // represents 500MB
    private string searchText = "";
    private string selectedExtension = ".png";
    private string errorMessage = "";
    private string alertClass = "";
    private int loadedFilesCount = 0;
    private double progress = 0;
    private double bufferValue = 0;
    private bool isDownloadFolder = true;
    private bool isConverted = false;
    private List<IBrowserFile> files = new();
    private List<IBrowserFile> initialFiles = new();
    private List<MemoryStream> convertedImages = new();
    private List<string> pictureExtensions = new();

    protected override async Task OnInitializedAsync()
    {
        pictureExtensions = imageService.GetPictureFormats();
        await LoadStates();
    }

    private async Task LoadStates()
    {
        selectedExtension = await secureStorage.GetAsync(nameof(selectedExtension)) ?? ".png";
        searchText = await secureStorage.GetAsync(nameof(searchText)) ?? "";
    }

    private async Task SaveStates()
    {
        await secureStorage.SetAsync(nameof(selectedExtension), selectedExtension);
        if (string.IsNullOrWhiteSpace(searchText))
        {
            secureStorage.Remove(nameof(searchText)); 
        }
        else
        {
            await secureStorage.SetAsync(nameof(searchText), searchText);
        }
    }

    private async Task FilterImages()
    {
        var output = initialFiles;

        if (string.IsNullOrWhiteSpace(searchText) is false)
        {
            output = output.Where(f => f.Name.Contains(searchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
        }

        files = output;
        await SaveStates();
    }

    private void UploadFiles(IReadOnlyList<IBrowserFile> files)
    {
        isConverted = false;
        foreach (var file in files)
        {
            this.files.Add(file);
            loadedFilesCount = this.files.Count;
            CalculateProgress();
        }

        initialFiles = this.files;
    }

    private async Task ConvertImages()
    {
        try
        {
            errorMessage = "";
            if (files.Count == 0)
            {
                GetAlertSeverity("Warning");
                errorMessage = "No files to convert.";
                return;
            }

            convertedImages.Clear();

            foreach (var file in files)
            {
                using (var stream = file.OpenReadStream(maxFileSize))
                using (var image = await Image.LoadAsync(stream))
                using (var convertedStream = new MemoryStream())
                {
                    await imageService.GetEncoderAsync(image, convertedStream, selectedExtension);
                    convertedStream.Position = 0;

                    convertedImages.Add(new MemoryStream(convertedStream.ToArray()));
                }
            }

            await SaveStates();
            isConverted = true;
        }
        catch (Exception ex)
        {
            GetAlertSeverity("Error");
            errorMessage = ex.Message;
        }
    }

    private async Task DownloadImages()
    {
        try
        {
            errorMessage = "";
            if (convertedImages.Count == 0 || files.Count == 0)
            {
                GetAlertSeverity("Warning");
                errorMessage = "No converted files to download.";
                return;
            }

            for (int i = 0; i < files.Count; i++)
            {
                var file = files[i];
                var convertedImage = convertedImages[i];

                string filePath = "";
                if (isDownloadFolder)
                {
                    filePath = imageService.GetDefaultDownloadPath(file, selectedExtension);
                }
                else
                {
                    filePath = imageService.GetPicturesDownloadPath(file, selectedExtension);
                }

                using (var outputStream = new FileStream(filePath, FileMode.Create))
                {
                    await convertedImage.CopyToAsync(outputStream);
                }
            }

            isConverted = false;
        }
        catch (Exception ex)
        {
            GetAlertSeverity("Error");
            errorMessage = ex.Message;
        }
    }

    private string GetButtonClass(bool isDownload)
    {
        if (isDownloadFolder == isDownload)
        {
            return "text-success";
        }

        return "text-danger";
    }

    private void GetAlertSeverity(string alert)
    {
        string output = alert switch
        {
            "Normal" => "Severity.Normal",
            "Info" => "Severity.Info",
            "Success" => "Severity.Success",
            "Warning" => "Severity.Warning",
            "Error" => "Severity.Error",
            _ => "Severity.Info",
        };

        alertClass = alert;
    }

    private string GetFilesCount()
    {
        string output = files?.Count switch
        {
            0 => "0 files",
            1 => "1 file",
            _ => $"{files?.Count} files",
        };

        return output;
    }

    private void ClearImages()
    {
        files.Clear();
        initialFiles.Clear();
        convertedImages.Clear();
        CalculateProgress();
        isConverted = false;
    }

    private void CalculateProgress()
    {
        int totalLoadedFiles = files.Count;
        if (files.Count == 0)
        {
            progress = 0;
            bufferValue = 0;
        }
        else
        {
            double progress = (double)loadedFilesCount / totalLoadedFiles * 100;
            double bufferValue = progress + 5;
            this.progress = progress;
            this.bufferValue = bufferValue;
        }
    }
}