@page "/"
@inject ISecureStorage secureStorage


<MudContainer>
    <h1 class="text-uppercase text-center">Convert Images</h1>
    <MudGrid>
        <MudItem xs="12" Class="text-center">
            <MudFileUpload T="IReadOnlyList<IBrowserFile>" FilesChanged="UploadFiles">
                <ButtonTemplate>
                    <MudButton HtmlTag="label"
                               Variant="Variant.Filled"
                               Color="MudBlazor.Color.Primary"
                               StartIcon="@Icons.Material.Filled.CloudUpload"
                               Class="w-100"
                               for="@context">
                        Multiple Files
                    </MudButton>
                </ButtonTemplate>
            </MudFileUpload>
            <MudButtonGroup Class="mt-2">
                <MudButton Class="@GetButtonClass(true)" OnClick="@(() => isDownloadFolder = true)">Download Folder</MudButton>
                <MudButton Class="@GetButtonClass(false)" OnClick="@(() => isDownloadFolder = false)">Picture Folder</MudButton>
            </MudButtonGroup>
            <MudSelect Label="Convert to:" @bind-Value="selectedExtension" Class="mud-input-root text-start">
                @foreach (var e in pictureExtensions)
                {
                    <MudSelectItem Value="@e">@e</MudSelectItem>
                }
            </MudSelect>
            <MudButton Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="mt-2" OnClick="ConvertImages">
                Convert
            </MudButton>
        </MudItem>
        <MudItem xs="12">
            <MudVirtualize Items="files" Context="f" OverscanCount="10">
                <MudCard Style="max-height: 250px;" Class="mb-3 p-2 border-dark">
                    <MudCardContent>
                        <MudText>@f.Name</MudText>
                        <MudText Typo="Typo.body2">@f.Size bytes</MudText>
                    </MudCardContent>
                    <MudSelect Label="Convert to:" @bind-Value="selectedExtension" Class="mud-input-root me-2">
                        @foreach (var e in pictureExtensions)
                        {
                            <MudSelectItem Value="@e">@e</MudSelectItem>
                        }
                    </MudSelect>
                    <MudCardActions Class="justify-content-between">
                        <MudButton Variant="Variant.Text" Color="MudBlazor.Color.Primary" OnClick="(() => ConvertImage(f))">
                            Convert
                        </MudButton>
                        <MudButton Variant="Variant.Text" Color="MudBlazor.Color.Secondary" OnClick="(() => files.Remove(f))">
                            Remove
                        </MudButton>
                    </MudCardActions>
                </MudCard>
            </MudVirtualize>
        </MudItem>
        <MudItem xs="12" md="8" lg="6" xl="4">
            <div class="text-center">
                @if (convertedImages.Count >= 1)
                {
                    <MudButton Class="btn-danger" OnClick="DownloadImages">Download Images</MudButton>
                }
            </div>
        </MudItem>
    </MudGrid>
</MudContainer>


@code {
    private long maxFileSize = 1024 * 1024 * 50; // represents 50MB
    private string selectedExtension = ".png";
    private string errorMessage = "";
    private bool isDownloadFolder = true;
    private List<IBrowserFile> files = new();
    private List<MemoryStream> convertedImages = new();
    private List<string> pictureExtensions = new()
    {
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".bmp",
        ".tiff",
        ".webp",
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadStates();
    }

    private async Task LoadStates()
    {
        selectedExtension = await secureStorage.GetAsync(nameof(selectedExtension)) ?? ".png";
    }

    private async Task SaveStates()
    {
        await secureStorage.SetAsync(nameof(selectedExtension), selectedExtension);
    }

    private void LoadFile(InputFileChangeEventArgs e)
    {
        files.Clear();
        files.AddRange(e.GetMultipleFiles());
    }

    private void UploadFiles(IReadOnlyList<IBrowserFile> files)
    {
        foreach (var file in files)
        {
            this.files.Add(file);
        }
    }

    private async Task ConvertImages()
    {
        if (files.Count == 0)
        {
            return;
        }

        convertedImages.Clear();

        foreach (var file in files)
        {
            using (var stream = file.OpenReadStream(maxFileSize))
            using (var image = await Image.LoadAsync(stream))
            using (var convertedStream = new MemoryStream())
            {
                await GetEncoder(image, convertedStream);
                convertedStream.Position = 0;

                convertedImages.Add(new MemoryStream(convertedStream.ToArray()));
            }
        }
        await SaveStates();
    }

    private async Task ConvertImage(IBrowserFile file)
    {
        using (var stream = file.OpenReadStream(maxFileSize))
        using (var image = await Image.LoadAsync(stream))
        using (var convertedStream = new MemoryStream())
        {
            await GetEncoder(image, convertedStream);
            convertedStream.Position = 0;

            convertedImages.Add(new MemoryStream(convertedStream.ToArray()));
        }

        await SaveStates();
    }

    private async Task DownloadImages()
    {
        if (convertedImages.Count == 0 || files.Count == 0)
        {
            return;
        }

        for (int i = 0; i < files.Count; i++)
        {
            var file = files[i];
            var convertedImage = convertedImages[i];

            string filePath = isDownloadFolder ? GetDefaultDownloadPath(file) : GetPicturesDownloadPath(file);

            using (var outputStream = new FileStream(filePath, FileMode.Create))
            {
                await convertedImage.CopyToAsync(outputStream);
            }
        }
    }

    private string GetDefaultDownloadPath(IBrowserFile file)
    {
        string downloadsFolder = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        string fileName = Path.GetFileNameWithoutExtension(file.Name) + selectedExtension;
        return Path.Combine(downloadsFolder, "Downloads", fileName);
    }

    private string GetPicturesDownloadPath(IBrowserFile file)
    {
        string downloadsFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
        string fileName = Path.GetFileNameWithoutExtension(file.Name) + selectedExtension;
        return Path.Combine(downloadsFolder, fileName);
    }

    private string GetButtonClass(bool isDownload)
    {
        if (isDownloadFolder == isDownload)
        {
            return "text-success";
        }

        return "text-danger";
    }

    private async Task GetEncoder(Image image, MemoryStream convertedStream)
    {
        switch (selectedExtension)
        {
            case ".png":
                await image.SaveAsPngAsync(convertedStream, new PngEncoder());
                break;

            case ".jpeg":
                await image.SaveAsJpegAsync(convertedStream, new JpegEncoder());
                break;

            case ".jpg":
                await image.SaveAsJpegAsync(convertedStream, new JpegEncoder());
                break;

            case ".gif":
                await image.SaveAsGifAsync(convertedStream, new GifEncoder());
                break;

            case ".bmp":
                await image.SaveAsBmpAsync(convertedStream, new BmpEncoder());
                break;

            case ".tiff":
                await image.SaveAsTiffAsync(convertedStream, new TiffEncoder());
                break;

            case ".webp":
                await image.SaveAsWebpAsync(convertedStream, new WebpEncoder());
                break;
        }
    }
}